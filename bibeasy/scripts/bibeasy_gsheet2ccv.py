#!/usr/bin/env python3
#
# This script is used for cross-referencing publication index between a custom
# Excel sheet and the XML-generated Canadian Common CV (CCV).
#
# Dependency:
# - Python 3.6 (+ common libraries)
#
# WARNING: To debug this script under Pycharm, set PYDEVD_USE_FRAME_EVAL=NO. More info at:
#  https://github.com/ContinuumIO/anaconda-issues/issues/8737
#
# Authors: Alexandru Foias, Julien Cohen-Adad

# TODO: add journal/conf to title when matching refs, to avoid duplicates (i.e. same title)
# TODO: Add * for supervised students
# TODO: Add check for journal name, volume, pages and authors
# TODO: use autocompletion: https://github.com/kislyuk/argcomplete


import pandas as pd
import logging
import coloredlogs
import argparse
import re
import fileinput

from bibeasy.utils import SmartFormatter
from bibeasy.utils import display_replacement, find_matching_ref, replace_ref, xml_to_df
from bibeasy.gsheet import fetch_gsheet_from_the_web

# Initialize logging
coloredlogs.install(fmt='%(message)s')
logging.basicConfig(level=logging.INFO)

# Associates the publication type to the proper index of the publication title from the CCV's XML file.
type2index = {'Journal Articles': 0, 'Conference Publications': 1}

# Associates the user's choice with CCV's publication type
usertype2ccvtype = {'article': 'Journal Articles', 'proceedings': 'Conference Publications'}

# Associates the user's choice with prefix used in input text file
usertype2prefix = {'article': 'J', 'proceedings': 'C'}


def get_parameters():
    parser = argparse.ArgumentParser(description=
"This script is used for cross-referencing publication index between a custom Excel sheet and the XML-generated "
"Canadian Common CV (CCV).\n"
"\n"
"Example 1: Make sure that all references in GoogleSheet are present in the CCV:\n"
"  bibeasy_gsheet2csv -x REF-CCV.xml\n\n"
"Example 2: References that need cross-correspondance between the CSV and the CCV; exclude refs older than 2014:\n"
"  bibeasy_gsheet2csv -c REF.CSV -x REF-CCV.xml -i TXT_IN.txt -y 2014\n\n"
"Example 3: Only output a list of CCV publications that correspond to the filter tag FILTER.\n"
"  bibeasy_gsheet2csv -c REF.CSV -x PUBLIS-CCV.xml -f FILTER\n",
                                     formatter_class=SmartFormatter)
    parser.add_argument("-x", "--xml",
                        help="XML file (generated by CCV website) which contains indexation used in output.",
                        required=True)
    parser.add_argument("-c", "--csv",
                        help="CSV file (e.g. generated from GoogleSheet) which contains indexation used in input. If "
                             "not provided, the script will look for the json file under bibeasy/credentials/.",
                        required=False)
    parser.add_argument("-i", "--input",
                        help="Text file which contains references, listed as: '[J12, J13, C8], [J74]', where 'J' "
                             "corresponds to journal publications and 'C' corresponds to conference proceedings.",
                        required=False)
    parser.add_argument("-t", "--type",
                        help="Publication type",
                        nargs='+',
                        choices=['article', 'proceedings'],
                        default=['article', 'proceedings'],
                        required=False)
    parser.add_argument("-o", "--output",
                        help="Text file to output with converted fields in the following format: [3], [5]",
                        required=False)
    parser.add_argument("-f", "--filter",
                        help="Name of a column in the PUBLIS-GSHEET file, which has an 'x' for each row that should be "
                             "selected and listed in the terminal output, with format: [3, 5, 14]",
                        required=False)
    parser.add_argument("-y", "--min-year",
                        help="Only select references that are superior or equal to the specified year.",
                        type=int,
                        required=False)
    return parser.parse_args()


def main():
    args = get_parameters()

    # Fetch GoogleSheet publication records
    if args.csv:
        # Use exported csv file
        df_csv = pd.read_csv(args.csv, delimiter=',')
    else:
        # Connect to Google API
        df_csv = fetch_gsheet_from_the_web(args.type)

    # Remove rows with empty title (those contain NaN)
    df_csv = df_csv.dropna(subset=['Title'])

    # Filter by tag
    if args.filter:
        df_csv = df_csv[df_csv[args.filter] == 'x']

    # Filter by minimum year
    if args.min_year:
        df_csv = df_csv[df_csv['Date'].astype(int) >= args.min_year]

    # Read XML file (CCV references)
    df_ccv = xml_to_df(args.xml)

    # Find matching refs between GoogleSheet and CCV publications and output csv2ccv conversion dict
    csv2ccv = find_matching_ref(df_csv, df_ccv, args.type)

    if args.input:
        # Open output file
        # TODO: reimplement output file name if needed
        # fout = open(args.output, 'w')

        # Read input text file
        for line in fileinput.input(args.input):
            list_ref_id = re.findall(usertype2prefix[args.type] + "\d+", line)
            # if found refs, replace CSV with CCV
            if list_ref_id:
                for i_id in list_ref_id:
                    # Trip delimiter
                    csvid = int(i_id[1:])
                    # Make sure this row hasn't been filtered
                    if df_csv[df_csv['ID'] == csvid].empty:
                        logging.debug("WARNING: CSV reference not found: {}".format(csvid))
                        ccvid = -2
                    else:
                        # try:
                        ccvid = csvid2ccvid[csvid]
                    line = replace_ref(
                        line, usertype2prefix[args.type] + str(csvid), usertype2prefix[args.type] + str(ccvid))
                    display_replacement(df_csv, csvid, ccvid)

            # Write output file
            # fout.write(line)
        # fout.close()
        print(line)


if __name__ == "__main__":
    main()
